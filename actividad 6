#include <iostream>
#include <vector>
#include <cmath>
#include <fstream>
#include <cstdlib>
#include <chrono>
#include <string>
#include <omp.h>  // <-- Asegúrate de compilar con -fopenmp

// ------------------------------------------------
// Declaración de variables globales para el dominio
// ------------------------------------------------
double x_ini = 0.0, x_fin = 2.0;
double y_ini = 0.0, y_fin = 1.0;

int case_selector = 1;  // Elegir de 1 a 4

// ------------------------------------------------
// Función fuente generalizada: ∇²V = f(x,y)
// ------------------------------------------------
double source_term(double x, double y) {
    switch (case_selector) {
        case 1:
            return (x*x + y*y) * std::exp(x * y);
        case 2:
            return 0.0;
        case 3:
            return 4.0;
        case 4:
            return x / y + y / x;
        default:
            return 0.0;
    }
}

// ------------------------------------------------
// Condiciones de frontera unificadas para cada caso
// ------------------------------------------------
static constexpr double EPS = 1e-12;

double boundary_condition(double x, double y) {
    switch (case_selector) {
        case 1:
            if (std::abs(x - x_ini) < EPS)   return 1.0;              // x = 0
            if (std::abs(x - x_fin) < EPS)   return std::exp(2.0 * y); // x = 2
            if (std::abs(y - y_ini) < EPS)   return 1.0;              // y = 0
            if (std::abs(y - y_fin) < EPS)   return std::exp(x);      // y = 1
            return 0.0;
        case 2:
            if (std::abs(x - x_ini) < EPS)   return std::log(y*y + 1.0); // x = 1
            if (std::abs(x - x_fin) < EPS)   return std::log(y*y + 4.0); // x = 2
            if (std::abs(y - y_ini) < EPS)   return 2.0 * std::log(x);   // y = 0
            if (std::abs(y - y_fin) < EPS)   return std::log(x*x + 1.0); // y = 1
            return 0.0;
        case 3:
            if (std::abs(x - x_ini) < EPS)   return (1.0 - y) * (1.0 - y);  // x = 1
            if (std::abs(x - x_fin) < EPS)   return (2.0 - y) * (2.0 - y);  // x = 2
            if (std::abs(y - y_ini) < EPS)   return x * x;                  // y = 0
            if (std::abs(y - y_fin) < EPS)   return (x - 2.0) * (x - 2.0);  // y = 2
            return 0.0;
        case 4:
            if (std::abs(x - x_ini) < EPS)   return y * std::log(y);            // x = 1
            if (std::abs(x - x_fin) < EPS)   return 2.0 * y * std::log(2.0*y);   // x = 2
            if (std::abs(y - y_ini) < EPS)   return x * std::log(x);            // y = 1
            if (std::abs(y - y_fin) < EPS)   return 2.0 * x * std::log(2.0*x);   // y = 2
            return 0.0;
        default:
            return 0.0;
    }
}

// ------------------------------------------------
// Inicialización de la malla (grid) y condiciones de frontera
// ------------------------------------------------
void initialize_grid(int M, int N, std::vector<std::vector<double>> &V, double &h, double &k) {
    h = (x_fin - x_ini) / M;
    k = (y_fin - y_ini) / N;
    V.resize(M + 1, std::vector<double>(N + 1, 0.0));

    for (int i = 0; i <= M; ++i) {
        double x = x_ini + i * h;
        for (int j = 0; j <= N; ++j) {
            double y = y_ini + j * k;
            if (i == 0 || i == M || j == 0 || j == N) {
                V[i][j] = boundary_condition(x, y);
            }
        }
    }
}

// ------------------------------------------------
// Solución iterativa de Poisson/Laplace por diferencias finitas
//   Ahora usa while(delta > tol) y cuenta iteraciones en 'iterations'.
// ------------------------------------------------
void solve_poisson(std::vector<std::vector<double>> &V,
                   int M, int N,
                   double h, double k,
                   double tol,
                   int &iterations)
{
    std::vector<std::vector<double>> V_old = V;
    iterations = 0;
    double delta = 0.0;

    // Repetir hasta que el máximo cambio sea menor que tol o lleguemos a 15000 iteraciones
    while (iterations < 15000) {  // Agregada condición de iteraciones máximas
        V_old = V;       // Guardamos el estado anterior
        double local_max = 0.0;

        // ------------------------------------------------
        // Actualización simultánea de todos los nodos interiores
        // ------------------------------------------------
        #pragma omp parallel for collapse(2) reduction(max:local_max)
        for (int i = 1; i < M; ++i) {
            for (int j = 1; j < N; ++j) {
                double x = x_ini + i * h;
                double y = y_ini + j * k;
                double f = source_term(x, y);

                double numer = (V_old[i + 1][j] + V_old[i - 1][j]) * (k * k)
                             + (V_old[i][j + 1] + V_old[i][j - 1]) * (h * h)
                             - f * (h * h) * (k * k);
                double denom = 2.0 * (h * h + k * k);

                double V_new = numer / denom;
                double diff = std::abs(V_new - V_old[i][j]);
                V[i][j] = V_new;

                if (diff > local_max) {
                    local_max = diff;
                }
            }
        }

        delta = local_max;

        // ------------------------------------------------
        // Incrementar contador de iteraciones
        // ------------------------------------------------
        #pragma omp atomic
        iterations++;

        // ------------------------------------------------
        // Salir si ya cumplimos la tolerancia
        // ------------------------------------------------
        if (delta <= tol) {
            break;
        }
    }
}

// El resto del código permanece igual...

int main() {
    // El código principal sigue sin cambios, solo se aplicó la condición en solve_poisson
    return 0;
}


